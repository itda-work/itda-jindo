package guide

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// HTMLTemplate is the template for HTML output
const HTMLTemplate = `<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --text-muted: #888;
            --accent: #7c3aed;
            --accent-light: #a78bfa;
            --border-color: #333;
            --code-bg: #0f0f1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--accent-light);
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        .meta {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .content {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .content h1, .content h2, .content h3, .content h4 {
            color: var(--accent-light);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        .content h1 { font-size: 1.6rem; }
        .content h2 { font-size: 1.4rem; }
        .content h3 { font-size: 1.2rem; }
        .content h4 { font-size: 1.1rem; }

        .content p {
            margin-bottom: 1rem;
        }

        .content ul, .content ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .content li {
            margin-bottom: 0.5rem;
        }

        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 0.9em;
        }

        .content pre {
            background: var(--code-bg);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        .content pre code {
            padding: 0;
            background: none;
        }

        .content blockquote {
            border-left: 3px solid var(--accent);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-muted);
        }

        .content strong {
            color: var(--accent-light);
        }

        .content a {
            color: var(--accent-light);
            text-decoration: none;
        }

        .content a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
            color: var(--text-muted);
            font-size: 0.85rem;
            text-align: center;
        }

        @media (max-width: 600px) {
            body {
                padding: 1rem;
            }
            .content {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>ðŸ“š {{.Title}}</h1>
        <p class="meta">{{.Meta}}</p>
    </header>
    <main class="content">
        {{.Content}}
    </main>
    <footer>
        Generated by jd guide | jindo - Claude Code Configuration Manager
    </footer>
</body>
</html>`

// HTMLData holds data for HTML template
type HTMLData struct {
	Title   string
	Meta    string
	Content string
}

// GenerateHTML generates an HTML file from markdown content
func GenerateHTML(guideType GuideType, id string, markdownContent string, createdAt time.Time) (string, error) {
	// Get HTML output directory
	home, err := os.UserHomeDir()
	if err != nil {
		return "", err
	}

	htmlDir := filepath.Join(home, ".claude", "jindo", "guides-html", string(guideType))
	if err := os.MkdirAll(htmlDir, 0755); err != nil {
		return "", err
	}

	// Convert markdown to HTML
	htmlContent := markdownToHTML(markdownContent)

	// Prepare template data
	var title string
	switch guideType {
	case TypeSkill:
		title = fmt.Sprintf("Skill Guide: %s", id)
	case TypeHook:
		title = fmt.Sprintf("Hook Guide: %s", id)
	case TypeAgent:
		title = fmt.Sprintf("Agent Guide: %s", id)
	case TypeCommand:
		title = fmt.Sprintf("Command Guide: %s", id)
	}

	meta := fmt.Sprintf("ìž‘ì„±: %s", createdAt.Format("2006-01-02 15:04"))

	// Generate HTML
	html := HTMLTemplate
	html = strings.ReplaceAll(html, "{{.Title}}", title)
	html = strings.ReplaceAll(html, "{{.Meta}}", meta)
	html = strings.ReplaceAll(html, "{{.Content}}", htmlContent)

	// Write HTML file
	htmlPath := filepath.Join(htmlDir, sanitizeFilename(id)+".html")
	if err := os.WriteFile(htmlPath, []byte(html), 0644); err != nil {
		return "", err
	}

	return htmlPath, nil
}

// OpenInBrowser opens the file in the default browser
func OpenInBrowser(path string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", path)
	case "linux":
		cmd = exec.Command("xdg-open", path)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", path)
	default:
		return fmt.Errorf("unsupported platform: %s", runtime.GOOS)
	}

	return cmd.Start()
}

// markdownToHTML converts markdown to HTML (simple implementation)
func markdownToHTML(md string) string {
	lines := strings.Split(md, "\n")
	var html strings.Builder
	inCodeBlock := false
	inList := false
	listType := ""

	for i := 0; i < len(lines); i++ {
		line := lines[i]

		// Code blocks
		if strings.HasPrefix(line, "```") {
			if inCodeBlock {
				html.WriteString("</code></pre>\n")
				inCodeBlock = false
			} else {
				html.WriteString("<pre><code>")
				inCodeBlock = true
			}
			continue
		}

		if inCodeBlock {
			html.WriteString(escapeHTML(line))
			html.WriteString("\n")
			continue
		}

		// Close list if needed
		trimmedLine := strings.TrimSpace(line)
		isListItem := strings.HasPrefix(trimmedLine, "- ") || strings.HasPrefix(trimmedLine, "* ") ||
			(len(trimmedLine) > 2 && trimmedLine[0] >= '1' && trimmedLine[0] <= '9' && trimmedLine[1] == '.')

		if inList && !isListItem && trimmedLine != "" {
			if listType == "ul" {
				html.WriteString("</ul>\n")
			} else {
				html.WriteString("</ol>\n")
			}
			inList = false
		}

		// Empty line
		if trimmedLine == "" {
			if !inList {
				html.WriteString("\n")
			}
			continue
		}

		// Headers
		if strings.HasPrefix(line, "#### ") {
			html.WriteString("<h4>")
			html.WriteString(processInline(line[5:]))
			html.WriteString("</h4>\n")
			continue
		}
		if strings.HasPrefix(line, "### ") {
			html.WriteString("<h3>")
			html.WriteString(processInline(line[4:]))
			html.WriteString("</h3>\n")
			continue
		}
		if strings.HasPrefix(line, "## ") {
			html.WriteString("<h2>")
			html.WriteString(processInline(line[3:]))
			html.WriteString("</h2>\n")
			continue
		}
		if strings.HasPrefix(line, "# ") {
			html.WriteString("<h1>")
			html.WriteString(processInline(line[2:]))
			html.WriteString("</h1>\n")
			continue
		}

		// Blockquote
		if strings.HasPrefix(line, "> ") {
			html.WriteString("<blockquote>")
			html.WriteString(processInline(line[2:]))
			html.WriteString("</blockquote>\n")
			continue
		}

		// Unordered list
		if strings.HasPrefix(trimmedLine, "- ") || strings.HasPrefix(trimmedLine, "* ") {
			if !inList || listType != "ul" {
				if inList {
					html.WriteString("</ol>\n")
				}
				html.WriteString("<ul>\n")
				inList = true
				listType = "ul"
			}
			content := trimmedLine[2:]
			html.WriteString("<li>")
			html.WriteString(processInline(content))
			html.WriteString("</li>\n")
			continue
		}

		// Ordered list
		if len(trimmedLine) > 2 && trimmedLine[0] >= '1' && trimmedLine[0] <= '9' && trimmedLine[1] == '.' {
			if !inList || listType != "ol" {
				if inList {
					html.WriteString("</ul>\n")
				}
				html.WriteString("<ol>\n")
				inList = true
				listType = "ol"
			}
			content := strings.TrimPrefix(trimmedLine[2:], " ")
			html.WriteString("<li>")
			html.WriteString(processInline(content))
			html.WriteString("</li>\n")
			continue
		}

		// Paragraph
		html.WriteString("<p>")
		html.WriteString(processInline(line))
		html.WriteString("</p>\n")
	}

	// Close any open list
	if inList {
		if listType == "ul" {
			html.WriteString("</ul>\n")
		} else {
			html.WriteString("</ol>\n")
		}
	}

	return html.String()
}

// processInline processes inline markdown (bold, italic, code, links)
func processInline(text string) string {
	// Escape HTML first
	text = escapeHTML(text)

	// Code (backticks) - process first to avoid conflicts
	text = processBackticks(text)

	// Bold
	text = processBold(text)

	// Italic
	text = processItalic(text)

	return text
}

func processBackticks(text string) string {
	var result strings.Builder
	inCode := false
	for i := 0; i < len(text); i++ {
		if text[i] == '`' {
			if inCode {
				result.WriteString("</code>")
				inCode = false
			} else {
				result.WriteString("<code>")
				inCode = true
			}
		} else {
			result.WriteByte(text[i])
		}
	}
	return result.String()
}

func processBold(text string) string {
	// **text** or __text__
	for {
		start := strings.Index(text, "**")
		if start == -1 {
			break
		}
		end := strings.Index(text[start+2:], "**")
		if end == -1 {
			break
		}
		text = text[:start] + "<strong>" + text[start+2:start+2+end] + "</strong>" + text[start+2+end+2:]
	}
	return text
}

func processItalic(text string) string {
	// *text* (but not **)
	var result strings.Builder
	i := 0
	for i < len(text) {
		if i < len(text)-1 && text[i] == '*' && text[i+1] != '*' {
			// Find closing *
			end := strings.Index(text[i+1:], "*")
			if end != -1 && (end+i+2 >= len(text) || text[end+i+2] != '*') {
				result.WriteString("<em>")
				result.WriteString(text[i+1 : i+1+end])
				result.WriteString("</em>")
				i = i + 1 + end + 1
				continue
			}
		}
		result.WriteByte(text[i])
		i++
	}
	return result.String()
}

func escapeHTML(text string) string {
	text = strings.ReplaceAll(text, "&", "&amp;")
	text = strings.ReplaceAll(text, "<", "&lt;")
	text = strings.ReplaceAll(text, ">", "&gt;")
	return text
}
